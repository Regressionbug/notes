[toc]

# 序论

**分析**：对问题和需求的调查研究

**设计**：满足需求的概念上的解决方案

**面向对象分析**：在问题领域内发现和描述对象

**面向对象设计**：定义软件对象以及它们如何协作以实现需求

**UML**：统一建模语言，是描述、构造和文档化系统制品的可视化语言；UML定义了各种UML简档，专用于某些常用主题领域的表示法子集

应用UML的三种方式:

+ 作为草图(敏捷建模所使用)
+ 作为蓝图
+ 作为编程语言

三种透视图:

+ 概念透视图:描述现实世界(概念类)
+ 规格说明(软件)透视图:描述软件抽象物,但并不约定特定实现(软件类)
+ 实现(软件)透视图:描述特定技术的软件实现(实现类)

**UP**：软件开发过程(software development process)描述了构造,部署以及维护软件的方式。

- 迭代的
- 灵活的
- 提供OOAD的示范结构

**迭代开发**：开发被组织成一系列固定的短期小项目,称为迭代(iteration)

- 小步骤：完整的需求分析、设计、实现、测试过程
- 反馈：明确需求和设计
- 调整：明确需求和设计

**迭代和增量式开发**：系统增量式地发展完善

**迭代和进化式开发**：规格说明和设计不断进化

迭代开发的优点:

+ 减少项目失败的可能性,提高生产率,降低缺陷率
+ 在早期缓解高风险
+ 早期可见的进展
+ 早期反馈,用户参与和调整,产生更接近涉众真实需求的精化系统
+ 可控复杂性
+ 一次迭代中的经验可以被系统地用于改进开发过程本身

**UP核心思想**：

- 短时间定量迭代
- 进化
- 适应性开发

**瀑布模型错误倾向**：规格说明是可预知的和稳定的,并且能在项目开始时就正确定义。同时具有低变更率

反馈和改写的必要性:

+ 来自**早期开发中的反馈**,有助于程序设计人员理解规格说明,客户演示也有助于精化需求
+ 来自**测试中的反馈**,有助于开发者精化设计或模型
+ 来自**团队处理早期特性过程中的反馈**,有助于精化时间表和估计
+ 来自**客户和市场的反馈**,有助于重新定义下一次迭代实现特性的优先级

**风险驱动的迭代开发**：更为明确地包含了以架构为中心迭代开发的实践,意味着早期迭代要致力于核心架构的构造\测试和稳定

**敏捷开发**：应用时间定量的迭代和进化式开发、使用自适应计划、提倡增量交付并包含其他敏捷性(快速和灵活的响应变更)

- 具备进化式精化的计划
- 需求和设计的短时间定量迭代
- 简易、轻量、沟通、自组织团队等更多敏捷性的实践和原则

**敏捷建模**：建模的目的主要是为了理解，而非文档

**敏捷UP**：

- 使用UP活动和制品的简集
- UP是迭代和不断进化的
- 不应有详细的计划

实践和价值:

+ 采用敏捷方法并不意味着不进行任何建模
+ 建模的主要目的是用于理解和沟通
+ 不要对所有或大多数的软件设计建模(只对困难和棘手的部分)
+ 尽可能使用最简单的工具
+ 不要单独建模
+ 并行地创建模型
+ 使用"足够好"的简单表示方法
+ 开发者为自己进行OO设计建模

**UP阶段**：

+ 初始(Inception):大体上的构想,业务案例,范围和模糊评估
+ 细化(Elaboration):已精化的构想,核心架构的迭代实现,高风险的解决,确定大多数需求和范围以及进行更为实际的评估
+ 构造(Construction):对遗留下来的风险较低的和比较简单的元素进行迭代实现,准备部署
+ 移交(Transistion):进行beta测试和部署

**UP科目**：科目(discipline)是在一个主题域中的一组活动(及相关制品)，制品(artifact)是对所有工作产品的统称

关注的三个科目:

+ 业务建模:领域模型制品,使领域中的重要概念可视化
+ 需求:捕获功能性需求和非功能性需求的用例模型及其补充性的规格说明书
+ 设计:设计模型制品,用于对软件对象进行设计



# 初始阶段

考虑的问题：

+ 项目设想和业务案例
+ 可行性分析
+ 购买还是开发？
+ 粗略的成本估计
+ 继续开发还是终止项目？

**初始阶段的目标并不是定义所有需求**，或产生可信的预算或项目计划，只是进行合理的调查，以判断是否值得继续深入研究

**大多数需求分析在细化阶段完成，并且伴以具有产品品质的早期编程和测试**

初始阶段制品的样例：

+ 设想和业务模型
+ 用例模型
+ 补充性规格说明
+ 词汇表：关键领域术语和数据字典
+ 风险列表和风险管理计划
+ 原型和概念验证：澄清设想，验证技术思路
+ 迭代计划
+ 阶段计划和软件开发计划
+ 业务案例：就特定项目，对步骤和制品进行定制的描述

初始阶段**绝不会引入大量图形**

建模的最大价值是增强理解(其中蕴含的思想)，而非记录可靠的规格说明

## 进化式需求

**需求**：就是系统必须提供的能力和必须遵从的条件。UP更推崇用“一种系统的方法来寻找，记录，组织和跟踪系统不断变更的需求”。

`FURPS+`分类：功能性/非功能性，功能性/质量属性

+ 功能性(Functinal)：特性，功能
+ 可用性(Usability)：人性化因素，文档
+ 可靠性(Reliability)：故障频率，可恢复性，可预测性，安全性
+ 性能(Performance)：响应时间，资源利用率，吞吐量，并发量
+ 可支持性(Supportability)：可维护性，国际化，可配置性
+ `+`：辅助行和次要性的因素，如：实现，接口，操作，包装，授权

需求制品：

+ 用例模型
+ 补充性规格说明：非功能性需求+不能表示为用例的需求
+ 词汇表：数据字典（数据需求，有效性规则，容许值等）
+ 设想：高阶需求
+ 业务规则

## 用例

**用例**：是文本形式的情节描述，一组相关的成功和失败场景集合，用以描述某参与者使用系统以实现某些目标

用例的本质是通过编写使用系统实现用户目标的情节来发现和记录功能性需求

**参与者**是某些具有行为的事物（人、系统或组织）

**场景**是参与者和系统之间的一系列特定的活动和交互，也称为用例实例

场景记录：

+ 参与者之间的交互
+ 确认过程（通常由系统完成）
+ 系统完成的状态变更

用例不是面向对象的，编写用例时也不会进行OO分析。

缺少用户参与是项目失败的主要原因，用例降低了这项工作的难度，且强调了用户的目标和观点。

参与者的三种类型：

+ 主要参与者：具有用户目标，并通过使用所讨论的系统的服务完成
+ 协助参与者：为所讨论的系统提供服务
+ 幕后参与者：在用例中具有影响或利益的其他参与者

### 详述用例

+ 用例名称
+ 范围：用例描述的是对一个系统的使用，则称之为系统用例;对于更广泛的范围，称之为业务用例
+ 级别：用户目标级别相当于基本业务流程;子功能级别的用例描述支持用户目标所需要的子步骤
+ 主要参与者
+ **涉众及其关注点列表**：用例应该包含满足所有涉众关注点的事物。在编写用例其余部分前确定涉众及其关注点，能更加清楚地了解详细的系统职责
+ 前置条件
+ 后置条件
+ 主成功场景和步骤（基本流程）：通常不包括任何条件和分支，保持一定的连惯性
+ 扩展（替代流程）：基本流程与替代流程相结合应该满足几乎所有涉众所关注的问题。扩展由两部分组成：条件和处理。对于任何步骤都有可能发生的条件，使用`*`标记，使用下划线表示所执行的第二个用例
+ 特殊需求：非功能性需求，质量属性和约束
+ 技术和数据变元表：如何实现系统

### 编写准则

+ 以无用户界面约束的本质风格编写用例，摒弃用户界面于思考范围之外
+ 在早期需求工作中避免具体，使用黑盒用例
+ 如何发现用例？确定系统边界->寻找主要参与者和目标（时间，系统重启，升级处理）->定义用例
+ 保留有用的用例：老板测试，EBP(Elementary Business Process基本业务过程)测试（增加可量化的业务价值），规模测试

### 如何使用

UP提倡用例驱动开发(use-case driven development)。

+ 功能首先记录在用例中
+ 用例是迭代计划的重要部分，也是预算的关键输入
+ 用例实现驱动设计
+ 用例影响用户手册的组织
+ 功能或系统测试应当符合用例场景

当详细定义了约10%的需求时，技术小组需要开始构建系统的产品化核心。

## 其他需求

在早期花费一定时间去理解非功能性需求是有帮助的，这对架构选择有重要影响。

**补充性规格说明**：非功能性需求，用例的“特殊需求”应该被归进补充性规格说明。

**设想**不应占据很长的篇幅。但不要在设想中只列出用例名：

+ 用例很多，太详细且层次低，人们需要主要思想的概要
+ 用例名称可能掩盖了涉众真正关心的主要特性
+ 有些特性跨越了多个用例或用例无关

先编写设想还是先编写用例？不需要严格定义，建议：

+ 编写简要的设想草案
+ 确定用户目标和对应的用例名称
+ 详细编写用例，并开始编写补充性规格说明
+ 精化设想

**词汇表(数据字典)**，记录关于数据的数据（元数据）文档，包括：

+ 别名
+ 描述
+ 格式（类型，长度，单位）
+ 与其他元素的关系
+ 值域
+ 验证规则

# 细化阶段

## 基础

细化包括：

+ 对核心、有风险的软件架构进行编程和测试
+ 发现并稳定需求的主体部分
+ 规避主要风险

细化不是设计阶段，也不要完成所有模型的开发。

架构原型(architectural prototype，可执行架构或架构基线)不是可以丢弃的原型，而是具有产品品质的最终系统的一部分。

## 领域模型

领域模型(domain model)是对领域内的概念类或现实世界中对象（而非软件对象）的可视化表示。

领域模型描述的信息也可以采用纯文本的方式表示。

软件对象的领域层：在表示层或UI层之下的软件对象层是由领域对象组成的——领域对象是表示问题领域空间的事物的软件对象，并且与业务逻辑或领域逻辑方法相关。

概念类是思想，事物或对象。符号是表示概念类的词语或图形。内涵即概念类的定义，外延为概念类所适用的一组示例。

领域模型不是数据模型，没有属性的概念类是合法的。

**动机：降低与OO建模之间的表示差异**

如何创建领域模型：

+ 寻找概念类
+ 将其绘制为UML类图中的类
+ 添加关联和属性

### 概念类

找到概念类的三个策略：

+ 重用和修改现有的模型
+ 使用分类列表：概念类的候选列表，建议加入优先级
+ 确定名词短语：语言分析

是否使用工具来维护模型：谁要使用这些更新的模型？为什么？

像地图绘制者的工作思维创建领域模型：使用地域中现有的名字，排除无关或超出范围的特性，不要凭空增加事物。

对于非现实世界，需要高度抽象，汲取领域专家所使用的核心词汇和概念。

如果我们认为概念类X不是现实中的数字或文本，那么X很有可能是概念类而不是属性。

使用描述类：如商品（实体）和商品描述（描述或抽象），或用于减少冗余信息（商品只需要对应一个描述类，而不需要包含详细信息）。

### 关联

关联是类的实例之间的关系，是否需要记录关联，要基于现实世界的需要，而不是基于软件的需要。以“类名-动词短语-类名”为关联命名。

关联的多重性定义了类A有多少个实例可以和类B的一个实例相关联。两个类之间可能存在多重关联。

### 属性

属性是对象的逻辑数据值。属性的完整语法：

```
可见性(public/private) 名称(first name): 类型(string/date) 可选值([0..1]) = 默认值(114514) {特性表(readonly)}
```

建议把所有的属性需求转移到词汇表中。

导出属性：由多重性的值导出，使用`/`标记。

大部分的属性类应该是简单的，通过关联而不是属性来表示概念类之间的关系。

何时需要定义新的类型：

+ 由不同小节组成（电话号码，人名）
+ 具有与之相关的操作（解析和校验）
+ 具有其他属性
+ 单位

属性不应表示概念类的关系，不要使用外键属性。

### 结论

领域模型是否正确没有唯一答案！